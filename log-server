#!/usr/bin/env ruby
#encoding: utf-8

require 'optparse'
require 'yaml'
require 'em-zeromq'

require 'active_record'
require 'logger'

require 'uri'
require 'multi_json'
require 'accept_language'
require 'useragent'
require 'geoip'

=begin 
=================================================================
	获取命令行参数
=================================================================
=end

options = {}

banner_str = <<end_of_banner
------------------ 程序说明 -------------------

------------------ 命令行说明 ---------------------
end_of_banner

option_parser = OptionParser.new do |opts|
	opts.banner = banner_str	
=begin
	title = '默认为48小时。=0，只抓新数据库中没的；>0，抓最新几个小时的'
	opts.on('-t TIME', '--time Time', Integer, title) do |value|
		options[:time] = value
	end
=end
end.parse!


=begin 
=================================================================
	读取配置文件
=================================================================
=end

config = YAML.load_file 'config.yml'
server_conf = config['server']
host = server_conf['host']
port = server_conf['port']

=begin
================================================================
	建立数据库连接
=================================================================
=end

ActiveRecord::Base.establish_connection config['database']
ActiveRecord::Base.logger = Logger.new STDERR

class DimReferer    < ActiveRecord::Base; has_many :fact_requests end
class DimLocation   < ActiveRecord::Base; has_many :fact_requests end
class DimLanguage   < ActiveRecord::Base; has_many :fact_requests end
class DimBrowser    < ActiveRecord::Base; has_many :fact_requests end
class DimMachine    < ActiveRecord::Base; has_many :fact_requests end
class DimUser	    < ActiveRecord::Base; has_many :fact_requests end
class DimHost	    < ActiveRecord::Base; has_many :fact_requests end
class DimRequesturi < ActiveRecord::Base; has_many :fact_requests end

class FactRequest   < ActiveRecord::Base 
	belongs_to :dim_referer
	belongs_to :dim_location
	belongs_to :dim_language
	belongs_to :dim_browser
	belongs_to :dim_machine
	belongs_to :dim_user
	belongs_to :dim_host
	belongs_to :dim_requesturi
=begin
	validates_presence_of :dim_referer
	validates_associated :dim_referer
=end
end


def create_tables
	ActiveRecord::Schema.define do
		create_table :fact_requests do |t|
			t.datetime 	:time,	    	:null=>false
			t.integer	:dim_referer_id
			t.integer 	:dim_location_id
			t.integer 	:dim_language_id
			t.integer 	:dim_browser_id
			t.integer 	:dim_machine_id
			t.integer 	:dim_user_id
			t.integer 	:dim_host_id
			t.integer 	:dim_requesturi_id
		end
		add_index :fact_requests, [:time], :unique

		create_table :dim_referers do |t|
			t.string	:host,		:null=>false
			t.integer	:uri_counter,	:default=>0
		end

		create_table :dim_locations do |t|
			t.string	:ip,		:null=>false
			t.string	:continent,	:null=>false
			t.string	:country,	:null=>false
			t.string	:city,		:null=>false
			t.integer	:uri_counter,	:default=>0
		end

		create_table :dim_languages do |t|
			t.string	:primary,	:null=>false
			t.string	:sub,		:null=>false
			t.string	:quality_value,	:null=>false
			t.integer	:uri_counter,	:default=>0
		end

		create_table :dim_browsers do |t|
			t.integer	:mobile,	:default=>0
			t.string	:platform,	:null=>false
			t.string	:browser,	:null=>false
			t.string	:version,	:null=>false
			t.integer	:uri_counter,	:default=>0
		end

		create_table :dim_machines do |t|
			t.string	:token_key,	:null=>false
			t.string	:hardware_key,	:null=>false
			t.integer	:uri_counter,	:default=>0
		end

		create_table :dim_users do |t|
			t.string	:user,		:null=>false
			t.integer	:uri_counter,	:default=>0
		end

		create_table :dim_hosts do |t|
			t.string	:host,		:null=>false
			t.integer	:uri_counter,	:default=>0
		end

		create_table :dim_requesturis do |t|
			t.string	:request_uri,	:null=>false
			t.integer	:uri_counter,	:default=>0
		end
	end
end

def drop_tables
	ActiveRecord::Schema.define do
		drop_table :fact_requests 	if FactRequest.table_exists?
		drop_table :dim_referers  	if DimReferer.table_exists?
		drop_table :dim_locations 	if DimLocation.table_exists?
		drop_table :dim_languages 	if DimLanguage.table_exists?
		drop_table :dim_browsers  	if DimBrowser.table_exists?
		drop_table :dim_machines  	if DimMachine.table_exists?
		drop_table :dim_users 	  	if DimUser.table_exists?
		drop_table :dim_hosts 	  	if DimHost.table_exists?
		drop_table :dim_requesturis 	if DimRequesturi.table_exists?
	end
end

drop_tables()

create_tables()


sample_json = '{"User-Id" : "hiand","Host" : "hi.baidu.com","Request URL" : "http://hi.baidu.com/chenshake/item/59c044fe49c3c6ef1b111ff8","Referer" : "https://www.google.com.hk/","User-Agent" : "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.52 Safari/537.17","Accept-Language" : "zh-CN,zh;q=0.8","Client-Ip" : "22.224.12.67"}'

def get_referer_id host

end

def get_location_id continent, country, city, timezone

end

def get_language_id primary, sub, quality_value

end

def get_browser_id mobile, platform, browser, version

end

def get_machine_id token, hardware

end

def get_user_id user

end

def get_host_id host

end

def get_requesturi_id uri

end

def import_database log_item
	puts log_item
end

def push_log item_json
	item = MultiJson.load item_json
	return false unless host = item['Host']
	return false unless url  = item['Request URL']
	return false unless referer = item['Referer']
	return false unless ua = item['User-Agent']
	return false unless language = item['Accept-Language']
	return false unless ip = item['Client-Ip']

	time = item['Time'] || Time.now.utc.to_s
	time = Time.parse(time).utc
	userid = item['User-Id'] || 'null'
	tokenid = item['Token-Id'] || 'null'
	machineid = item['Machine-Id'] || 'null'

	city = GeoIP.new('GeoLiteCity.dat').city(ip)
	if city 
		continent = city.continent_code || 'null'
		country = city.country_name || 'null'
		cityname = city.city_name || 'null'
		timezone = city.timezone || 'null'
	else
		continent = country = cityname = timezone = 'null'
	end

	new_lang = language.split /[,|;]/
	lang = AcceptLanguage::Parser::Phrase.new(new_lang[0]+';'+new_lang[-1])
	if lang
		primary = lang.primary || 'null'
		sub = lang.sub || 'null'
		quality_value = lang.quality_value || 'null'
	else
		primary = sub = quality_value = 'null'
	end

	user_agent = UserAgent.parse ua
	if user_agent
		mobile = user_agent.mobile? || false
		platform = user_agent.platform || 'null'
		browser = user_agent.browser || 'null'
		version = user_agent.version || 'null'
	else
		mobile = false
		platform = browser = version = 'null'
	end

	log_item = [time]
	log_item << get_machine_id(tokenid, machineid)
	log_item << get_user_id(userid)
	log_item << get_language_id(primary, sub, quality_value)
	log_item << get_browser_id(mobile, platform, browser, version)
	log_item << get_location_id(continent, country, cityname, timezone)
	log_item << get_referer_id(referer)
	log_item << get_host_id(host)
	log_item << get_requesturi_id(url)

	import_database log_item

	true
end

unless push_log(sample_json)
	puts 'input parmameter error!'
end


exit 0

=begin 
=================================================================
	监听zeromq
=================================================================
=end

Thread.abort_on_exception = true

trap('INT') do
  EM::stop()
end

puts "Started (with zmq #{ZMQ::Util.version.join('.')})."

zmq = EM::ZeroMQ::Context.new(1)

EM.run do
	# setup pull sockets
	pull_srv = zmq.socket(ZMQ::PULL)

	pull_srv.hwm = 10000
	pull_srv.swap = 1024 * 4 * 256

	# push_socket1.hwm = 40
	puts "HWM: #{pull_srv.hwm}"
	puts "SWAP: #{pull_srv.swap}"

	pull_srv.bind("tcp://#{host}:#{port}")

	pull_srv.on(:message) { |msg|
		puts msg.copy_out_string
		msg.close
	}
end

puts "Completed."

